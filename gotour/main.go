package main

import "fmt"

// n は生成するフィボナッチ数の個数を指定。
// c は int 型のチャネル。
func fibonacci(n int, c chan int) {
	// フィボナッチ数列の最初の値を準備
	x, y := 0, 1
	for i := 0; i < n; i++ {
		// フィボナッチ数列の各値をチャネル c に送信
		c <- x
		// x を y に、y を次のフィボナッチ数に更新
		x, y = y, x+y
	}
	close(c) // これ以上値を送信しないのでチャネルを閉じる
}

func main() {
	// int 型のバッファ付きチャネル c を作成
	// バッファサイズは 10
	c := make(chan int, 10)
	//cap(c)  はチャネルのバッファサイズ
	// fibonacci 関数は新しい Goroutine として非同期に実行
	// cap は、配列、スライス、チャネルなどの容量（キャパシティ）を返す組み込み関数
	go fibonacci(cap(c), c)
	// range ループは、チャネルが閉じられるまで値を受信し続ける
	// チャネルが閉じられると自動的にループが終了
	for i := range c {
		fmt.Println(i)
	}
}

// チャネルを閉じることで、受信側はこれ以上新しい値が来ないことを知り、range ループが終了する。

// 0
// 1
// 1
// 2
// 3
// 5
// 8
// 13
// 21
// 34

// cap(c)
// ・チャネル c に使用すると、そのチャネルのバッファサイズを返す
// ・配列やスライスでは、cap はそのデータ構造が保持できる要素の最大数を返す
// ・チャネルに対して cap(c) を使うと、
// 　チャネルのバッファサイズ（つまり、チャネルに一度に格納できるデータの最大数）を返す。
// c := make(chan int, 10)
// fmt.Println(cap(c)) // 出力: 10
